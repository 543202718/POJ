# POJ
以三元组（带宽，价格，种类）描述设备，将所有的设备按照带宽降序排序。遍历所有设备，维护每个种类目前最低价格的设备，把它们的总价记作P，把当前设备的带宽记作B，并以此计算B/P。最终输入最大的B/P。

实际上是贪心算法，时间复杂度$O(tn^2logn)$。

```cpp
#include <iostream>
#include <algorithm>
#include <stdio.h>
#define INF 999999
using namespace std;
struct device
{
	int bandwidth, price, kind;
};


bool compare(const device &x, const device &y) {
	return x.bandwidth > y.bandwidth;
}

device a[10010];
int b[110], p;
int main() {
	int t;
	cin >> t;
	while (t--) {
		int n, num = 0, m;
		cin >> n;
		for (int i = 0; i < n; i++) {
			int m;
			cin >> m;
			for (int j = 0; j < m; j++) {
				a[num].kind = i;
				cin >> a[num].bandwidth >> a[num].price;
				num++;
			}
		}
		sort(a, a + num, compare);
		for (int i = 0; i < n; i++) {
			b[i] = INF;
		}
		p = n * INF;
		double maxValue = 0;
		for (int i = 0; i < num; i++) {
			if (a[i].price < b[a[i].kind]) {
				p = p - b[a[i].kind] + a[i].price;
				b[a[i].kind] = a[i].price;
			}
			maxValue = max(maxValue, ((double)a[i].bandwidth / p));
		}
		cout.precision(3);
		printf("%.3f\n", maxValue);
	}
	return 0;
}
```